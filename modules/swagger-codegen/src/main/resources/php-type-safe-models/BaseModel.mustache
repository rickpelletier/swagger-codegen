<?php
/**
 * BaseModel
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   Display Name <richard.p@irokopartners.com>
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{modelPackage}};

use Carbon\Carbon;
use \JsonSerializable;
use \Illuminate\Contracts\Support\Arrayable;
use \Illuminate\Support\MessageBag;

/**
 * BaseModel Class Doc Comment
 *
 * @category    Class
 * @description Concrete implementation of JsonSerializable Model
 * @package     App
 * @author      Display Name <richard.p@irokopartners.com>
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class BaseModel implements JsonSerializable, Arrayable
{
    protected $validationErrors;

    /**
     * Constructor
     * @param mixed[] $data array or json string containing data to initialize
     * the model
     */
    public function __construct($data = null)
    {
        $this->validationErrors = new MessageBag();
        if ($data !== null) {
            $this->load($data);
        }
    }

    /**
     * Returns the string representation of this object
     * @return string The json representation of this object
     * the model
     */
    public function __toString()
    {
        return json_encode($this);
    }

    /**
     * Prepares this object for json serialization
     * @see \JsonSerializable::jsonSerialize()
     * @return array
     */
    public function jsonSerialize()
    {
        // check for datetimes, and reconstruct them into RFC3339 strings
        $arr = $this->toArray();
        foreach ($arr as $key => $value) {
            if ($value instanceof Carbon) {
                $arr[$key] = $value->toRfc3339String();
            }
            // don't serialize null values
            if ($value === null) {
                unset($arr[$key]);
            }
        }
        return $arr;
    }

    /**
     * Returns an array representation of the object's properties
     * @see \Illuminate\Contracts\Support\Arrayable::toArray()
     * @return array
     */
    public function toArray()
    {
        // Do not include the validation errors
        $vars = get_object_vars($this);
        unset($vars["validationErrors"]);
        return $vars;
    }

    /**
     * Returns the array of field-level validation failures
     *
     * @return ValidationErrorCollection
     */
    public function getValidationErrors()
    {
        return $this->validationErrors;
    }

    /**
     * Confirms that property value types match the list of language specific primitives defined during codegen
     *
     * @param mixed  $value The value to type check
     * @param string $type  The expected type
     *
     * @return boolean
     */
    protected function isValid($value, $type)
    {
        switch ($type) {
            case "boolean":
                return is_bool($value);
            break;
            case "int":
                return is_int($value);
            break;
            case "integer":
                return is_integer($value);
            break;
            case "double":
                return is_double($value);
            break;
            case "float":
                return is_float($value);
            break;
            case "string":
                return is_string($value);
            break;
            case "object":
                return is_object($value);
            break;
            case "DateTime":
                // Swagger specifications require RFC_3339
                return Carbon::createFromFormat(DATE_RFC3339, $value) !== false;
            break;
            case "mixed":
                // ??
                return true;
            break;
            case "number":
                return is_numeric($value);
            break;
            default:
                return true;
        }
    }

    protected function createDateTime($keyName, $data)
    {
        $obj = null;
        if (is_object($data[$keyName])
            && get_class($data[$keyName]) === '\Carbon\Carbon'
        ) {
            // assign it directly
            $obj = $data[$keyName];
        } else {
            // parse the value to a Carbon datetime
            try {
                $obj = Carbon::createFromFormat(
                    DATE_RFC3339,
                    $data[$keyName]
                );
            } catch (\Exception $ex) {
                $obj = new Carbon('1970-01-01');
            }

        }
        return $obj;
    }
}